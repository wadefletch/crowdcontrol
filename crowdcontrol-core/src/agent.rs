use anyhow::{anyhow, Context, Result};
use chrono::{DateTime, Utc};
use fs2::FileExt;
use serde::{Deserialize, Serialize};
use std::fs::{self, OpenOptions};
use std::io::{Read, Seek, Write};
use std::path::PathBuf;
use std::process::Command;
use tracing::{debug, info, trace};

use crate::{Agent, AgentStatus, Config};

#[derive(Debug, Serialize, Deserialize)]
pub struct AgentMetadata {
    #[serde(rename = "_comment")]
    pub comment: String,
    pub name: String,
    pub repository: String,
    pub branch: Option<String>,
    pub created_at: DateTime<Utc>,
    pub container_id: Option<String>,
}

pub fn save_agent_metadata(config: &Config, agent: &Agent) -> Result<()> {
    let metadata_path = config
        .agent_workspace_path(&agent.name)
        .join(".crowdcontrol")
        .join("metadata.json");

    debug!(
        "Saving metadata for agent '{}' to {:?}",
        agent.name, metadata_path
    );

    // Ensure parent directory exists
    if let Some(parent) = metadata_path.parent() {
        trace!("Creating parent directory: {:?}", parent);
        fs::create_dir_all(parent)?;
    }

    let metadata = AgentMetadata {
        comment: "This file is auto-generated by CrowdControl. Do not edit manually.".to_string(),
        name: agent.name.clone(),
        repository: agent.repository.clone(),
        branch: agent.branch.clone(),
        created_at: agent.created_at,
        container_id: agent.container_id.clone(),
    };

    let json = serde_json::to_string_pretty(&metadata)?;

    // Open file with write/create permissions
    let mut file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open(&metadata_path)
        .with_context(|| format!("Failed to open metadata file: {:?}", metadata_path))?;

    // Lock file exclusively for writing
    trace!("Acquiring exclusive lock on metadata file");
    file.lock_exclusive().with_context(|| {
        format!(
            "Failed to acquire lock on metadata file: {:?}",
            metadata_path
        )
    })?;

    // Write the data
    let write_result = file
        .write_all(json.as_bytes())
        .with_context(|| format!("Failed to write agent metadata to {:?}", metadata_path));

    // Always unlock, even if write failed
    trace!("Releasing lock on metadata file");
    file.unlock()
        .with_context(|| format!("Failed to unlock metadata file: {:?}", metadata_path))?;

    write_result?;
    debug!("Successfully saved metadata for agent '{}'", agent.name);
    Ok(())
}

pub fn load_agent_metadata(config: &Config, name: &str) -> Result<Agent> {
    let workspace_path = config.agent_workspace_path(name);
    let metadata_path = workspace_path.join(".crowdcontrol").join("metadata.json");

    debug!(
        "Loading metadata for agent '{}' from {:?}",
        name, metadata_path
    );

    if !metadata_path.exists() {
        debug!("Metadata file not found for agent '{}'", name);
        return Err(anyhow!("Agent '{}' not found", name));
    }

    // Open file for reading
    let mut file = OpenOptions::new()
        .read(true)
        .open(&metadata_path)
        .with_context(|| format!("Failed to open metadata file: {:?}", metadata_path))?;

    // Lock file shared for reading (multiple readers allowed)
    file.lock_shared().with_context(|| {
        format!(
            "Failed to acquire lock on metadata file: {:?}",
            metadata_path
        )
    })?;

    // Read the contents
    let mut json = String::new();
    let read_result = file
        .read_to_string(&mut json)
        .with_context(|| format!("Failed to read agent metadata from {:?}", metadata_path));

    // Always unlock, even if read failed
    file.unlock()
        .with_context(|| format!("Failed to unlock metadata file: {:?}", metadata_path))?;

    read_result?;

    let metadata: AgentMetadata =
        serde_json::from_str(&json).with_context(|| "Failed to parse agent metadata")?;

    Ok(Agent {
        name: metadata.name,
        status: AgentStatus::Created,
        container_id: metadata.container_id,
        repository: metadata.repository,
        branch: metadata.branch,
        created_at: metadata.created_at,
        workspace_path,
    })
}

pub fn list_all_agents(config: &Config) -> Result<Vec<String>> {
    let mut agents = Vec::new();

    if !config.workspaces_dir.exists() {
        return Ok(agents);
    }

    for entry in fs::read_dir(&config.workspaces_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            let metadata_path = path.join(".crowdcontrol").join("metadata.json");
            if metadata_path.exists() {
                if let Some(name) = path.file_name() {
                    agents.push(name.to_string_lossy().to_string());
                }
            }
        }
    }

    Ok(agents)
}

/// Update agent metadata atomically with file locking
/// This function loads the current metadata, applies the update function, and saves it back
pub fn update_agent_metadata<F>(config: &Config, name: &str, update_fn: F) -> Result<()>
where
    F: FnOnce(&mut Agent) -> Result<()>,
{
    let workspace_path = config.agent_workspace_path(name);
    let metadata_path = workspace_path.join(".crowdcontrol").join("metadata.json");

    if !metadata_path.exists() {
        return Err(anyhow!("Agent '{}' not found", name));
    }

    // Open file for read/write
    let mut file = OpenOptions::new()
        .read(true)
        .write(true)
        .open(&metadata_path)
        .with_context(|| format!("Failed to open metadata file: {:?}", metadata_path))?;

    // Lock file exclusively for the entire operation
    file.lock_exclusive().with_context(|| {
        format!(
            "Failed to acquire lock on metadata file: {:?}",
            metadata_path
        )
    })?;

    // Read current data
    let mut json = String::new();
    file.read_to_string(&mut json)?;

    let metadata: AgentMetadata =
        serde_json::from_str(&json).with_context(|| "Failed to parse agent metadata")?;

    // Create agent from metadata
    let mut agent = Agent {
        name: metadata.name,
        status: AgentStatus::Created,
        container_id: metadata.container_id,
        repository: metadata.repository,
        branch: metadata.branch,
        created_at: metadata.created_at,
        workspace_path: workspace_path.clone(),
    };

    // Apply the update
    update_fn(&mut agent)?;

    // Convert back to metadata
    let updated_metadata = AgentMetadata {
        comment: "This file is auto-generated by CrowdControl. Do not edit manually.".to_string(),
        name: agent.name.clone(),
        repository: agent.repository.clone(),
        branch: agent.branch.clone(),
        created_at: agent.created_at,
        container_id: agent.container_id.clone(),
    };

    let updated_json = serde_json::to_string_pretty(&updated_metadata)?;

    // Truncate and rewrite the file
    file.set_len(0)?;
    file.seek(std::io::SeekFrom::Start(0))?;
    file.write_all(updated_json.as_bytes())?;

    // Unlock the file
    file.unlock()?;

    Ok(())
}

pub fn validate_agent_name(name: &str) -> Result<()> {
    if name.is_empty() {
        return Err(anyhow!("Agent name cannot be empty"));
    }

    if !name
        .chars()
        .all(|c| c.is_alphanumeric() || c == '-' || c == '_')
    {
        return Err(anyhow!(
            "Agent name can only contain alphanumeric characters, hyphens, and underscores"
        ));
    }

    if name.len() > 64 {
        return Err(anyhow!("Agent name must be 64 characters or less"));
    }

    Ok(())
}

pub fn clone_repository(
    repository: &str,
    target_path: &PathBuf,
    branch: Option<&str>,
) -> Result<()> {
    let mut cmd = Command::new("git");
    cmd.arg("clone");

    if let Some(branch_name) = branch {
        cmd.arg("-b").arg(branch_name);
        info!(
            "Cloning repository {} (branch: {}) to {:?}",
            repository, branch_name, target_path
        );
    } else {
        info!("Cloning repository {} to {:?}", repository, target_path);
    }

    cmd.arg(repository).arg(target_path);

    debug!("Executing git command: {:?}", cmd);
    let output = cmd.output().context("Failed to execute git clone")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(anyhow!("Failed to clone repository: {}", stderr));
    }

    debug!("Repository cloned successfully");
    Ok(())
}

pub fn verify_repository_setup(workspace_path: &PathBuf) -> Result<bool> {
    // Find the repository directory
    let repo_dirs: Vec<_> = fs::read_dir(workspace_path)?
        .filter_map(|entry| entry.ok())
        .filter(|entry| entry.path().is_dir())
        .filter(|entry| !entry.file_name().to_string_lossy().starts_with('.'))
        .collect();

    if repo_dirs.is_empty() {
        return Err(anyhow!("No repository directory found in workspace"));
    }

    if repo_dirs.len() > 1 {
        return Err(anyhow!("Multiple directories found in workspace"));
    }

    let repo_path = repo_dirs[0].path();
    let crowdcontrol_dir = repo_path.join(".crowdcontrol");

    Ok(crowdcontrol_dir.exists())
}

pub fn format_duration(created_at: DateTime<Utc>) -> String {
    let now = Utc::now();
    let duration = now.signed_duration_since(created_at);

    if duration.num_days() > 0 {
        format!("{}d ago", duration.num_days())
    } else if duration.num_hours() > 0 {
        format!("{}h ago", duration.num_hours())
    } else if duration.num_minutes() > 0 {
        format!("{}m ago", duration.num_minutes())
    } else {
        "just now".to_string()
    }
}
